import type { PathfindingAlgorithmType } from "@/lib/store";
import type { PathfindingStep } from "./types";

/**
 * Step type labels for display in the UI.
 */
export const PATHFINDING_STEP_LABELS: Record<PathfindingStep["type"], string> = {
  visit: "Exploring node",
  current: "Processing node",
  path: "Building path",
  "no-path": "No path found",
};

/**
 * Metadata for each pathfinding algorithm.
 */
export interface PathfindingAlgorithmMetadata {
  /** Display name for the algorithm */
  label: string;
  /** Short label for compact display */
  shortLabel: string;
  /** Time complexity notation */
  complexity: string;
  /** Space complexity notation */
  spaceComplexity: string;
  /** Brief description of how the algorithm works */
  description: string;
  /** Whether this algorithm guarantees shortest path */
  guaranteesShortestPath: boolean;
  /** Visual pattern description */
  visualPattern: string;
  /** Source code lines for display */
  code: string[];
  /** Maps step types to their corresponding line indices (0-based) */
  lineMapping: Partial<Record<PathfindingStep["type"], number>>;
}

/**
 * Pathfinding algorithm metadata registry.
 */
export const PATHFINDING_ALGO_METADATA: Record<
  PathfindingAlgorithmType,
  PathfindingAlgorithmMetadata
> = {
  bfs: {
    label: "Breadth-First Search",
    shortLabel: "BFS",
    complexity: "O(V + E)",
    spaceComplexity: "O(V)",
    description:
      "Explores layer by layer, visiting all neighbors before moving deeper. Guarantees shortest path in unweighted graphs.",
    guaranteesShortestPath: true,
    visualPattern: "Flood expansion",
    code: [
      "function* bfs(grid, start, end) {",
      "  const queue = [{ coord: start, dist: 0 }];",
      "  const visited = new Set([key(start)]);",
      "  const parent = new Map();",
      "",
      "  while (queue.length > 0) {",
      "    // Dequeue front element",
      "    const { coord, dist } = queue.shift();",
      "    yield { type: 'current', coord, dist };",
      "",
      "    // Check if we reached the end",
      "    if (equals(coord, end)) {",
      "      yield* reconstructPath(parent, start, end);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord, dist };",
      "",
      "    // Explore all neighbors",
      "    for (const neighbor of getNeighbors(coord)) {",
      "      if (!visited.has(key(neighbor))) {",
      "        visited.add(key(neighbor));",
      "        parent.set(key(neighbor), coord);",
      "        queue.push({ coord: neighbor, dist: dist + 1 });",
      "      }",
      "    }",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 8,
      path: 12,
      visit: 16,
      "no-path": 28,
    },
  },

  dfs: {
    label: "Depth-First Search",
    shortLabel: "DFS",
    complexity: "O(V + E)",
    spaceComplexity: "O(V)",
    description:
      "Explores as deep as possible before backtracking. Does not guarantee shortest path but uses less memory.",
    guaranteesShortestPath: false,
    visualPattern: "Snake exploration",
    code: [
      "function* dfs(grid, start, end) {",
      "  const stack = [{ coord: start, dist: 0 }];",
      "  const visited = new Set();",
      "  const parent = new Map();",
      "",
      "  while (stack.length > 0) {",
      "    // Pop from top of stack",
      "    const { coord, dist } = stack.pop();",
      "",
      "    if (visited.has(key(coord))) continue;",
      "    visited.add(key(coord));",
      "",
      "    yield { type: 'current', coord, dist };",
      "",
      "    // Check if we reached the end",
      "    if (equals(coord, end)) {",
      "      yield* reconstructPath(parent, start, end);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord, dist };",
      "",
      "    // Push neighbors to stack (reverse for consistent order)",
      "    for (const neighbor of getNeighbors(coord).reverse()) {",
      "      if (!visited.has(key(neighbor))) {",
      "        parent.set(key(neighbor), coord);",
      "        stack.push({ coord: neighbor, dist: dist + 1 });",
      "      }",
      "    }",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 12,
      path: 16,
      visit: 20,
      "no-path": 31,
    },
  },

  dijkstra: {
    label: "Dijkstra's Algorithm",
    shortLabel: "Dijkstra",
    complexity: "O((V + E) log V)",
    spaceComplexity: "O(V)",
    description:
      "Uses a priority queue to always explore the nearest unvisited node. Guarantees shortest path even in weighted graphs.",
    guaranteesShortestPath: true,
    visualPattern: "Radial expansion",
    code: [
      "function* dijkstra(grid, start, end) {",
      "  const pq = new MinHeap();",
      "  pq.push({ coord: start, dist: 0 });",
      "",
      "  const distances = new Map([[key(start), 0]]);",
      "  const visited = new Set();",
      "  const parent = new Map();",
      "",
      "  while (pq.size > 0) {",
      "    // Extract minimum distance node",
      "    const { coord, dist } = pq.pop();",
      "",
      "    if (visited.has(key(coord))) continue;",
      "    visited.add(key(coord));",
      "",
      "    yield { type: 'current', coord, dist };",
      "",
      "    if (equals(coord, end)) {",
      "      yield* reconstructPath(parent, start, end);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord, dist };",
      "",
      "    // Relax edges to neighbors",
      "    for (const neighbor of getNeighbors(coord)) {",
      "      const newDist = dist + 1;",
      "      const oldDist = distances.get(key(neighbor)) ?? Infinity;",
      "",
      "      if (newDist < oldDist) {",
      "        distances.set(key(neighbor), newDist);",
      "        parent.set(key(neighbor), coord);",
      "        pq.push({ coord: neighbor, dist: newDist });",
      "      }",
      "    }",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 15,
      path: 18,
      visit: 22,
      "no-path": 37,
    },
  },

  astar: {
    label: "A* Search",
    shortLabel: "A*",
    complexity: "O((V + E) log V)",
    spaceComplexity: "O(V)",
    description:
      "Uses heuristic (Manhattan distance) to guide search toward goal. More efficient than Dijkstra for point-to-point search.",
    guaranteesShortestPath: true,
    visualPattern: "Directed expansion",
    code: [
      "function* aStar(grid, start, end) {",
      "  const pq = new MinHeap();",
      "  const h = manhattan(start, end);",
      "  pq.push({ coord: start, g: 0, f: h });",
      "",
      "  const gScores = new Map([[key(start), 0]]);",
      "  const closed = new Set();",
      "  const parent = new Map();",
      "",
      "  while (pq.size > 0) {",
      "    // Extract node with lowest f-score",
      "    const { coord, g } = pq.pop();",
      "",
      "    if (closed.has(key(coord))) continue;",
      "    closed.add(key(coord));",
      "",
      "    yield { type: 'current', coord, distance: g };",
      "",
      "    if (equals(coord, end)) {",
      "      yield* reconstructPath(parent, start, end);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord, distance: g };",
      "",
      "    for (const neighbor of getNeighbors(coord)) {",
      "      if (closed.has(key(neighbor))) continue;",
      "",
      "      const tentativeG = g + 1;",
      "      const currentG = gScores.get(key(neighbor)) ?? Infinity;",
      "",
      "      if (tentativeG < currentG) {",
      "        parent.set(key(neighbor), coord);",
      "        gScores.set(key(neighbor), tentativeG);",
      "        const f = tentativeG + manhattan(neighbor, end);",
      "        pq.push({ coord: neighbor, g: tentativeG, f });",
      "      }",
      "    }",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 16,
      path: 19,
      visit: 23,
      "no-path": 40,
    },
  },

  greedy: {
    label: "Greedy Best-First",
    shortLabel: "Greedy",
    complexity: "O((V + E) log V)",
    spaceComplexity: "O(V)",
    description:
      "Uses only the heuristic to guide search, ignoring path cost. Very fast but does not guarantee shortest path. Gets stuck in concave obstacles.",
    guaranteesShortestPath: false,
    visualPattern: "Laser beam",
    code: [
      "function* greedyBestFirst(grid, start, end) {",
      "  const pq = new MinHeap();",
      "  const h = manhattan(start, end);",
      "  // Priority is heuristic only (f = h)",
      "  pq.push({ coord: start, h });",
      "",
      "  const closed = new Set();",
      "  const parent = new Map();",
      "",
      "  while (pq.size > 0) {",
      "    // Extract node with lowest h-score",
      "    const { coord } = pq.pop();",
      "",
      "    if (closed.has(key(coord))) continue;",
      "    closed.add(key(coord));",
      "",
      "    yield { type: 'current', coord };",
      "",
      "    if (equals(coord, end)) {",
      "      yield* reconstructPath(parent, start, end);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord };",
      "",
      "    for (const neighbor of getNeighbors(coord)) {",
      "      if (closed.has(key(neighbor))) continue;",
      "",
      "      if (!parent.has(key(neighbor))) {",
      "        parent.set(key(neighbor), coord);",
      "        // Only heuristic matters - ignore cost so far",
      "        const h = manhattan(neighbor, end);",
      "        pq.push({ coord: neighbor, h });",
      "      }",
      "    }",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 16,
      path: 19,
      visit: 23,
      "no-path": 37,
    },
  },

  flood: {
    label: "Flood Fill",
    shortLabel: "Flood",
    complexity: "O(V + E)",
    spaceComplexity: "O(V)",
    description:
      "Wave propagation that explores every reachable node, not just the path to the goal. Shows the complete basin of attraction from the start.",
    guaranteesShortestPath: true,
    visualPattern: "Complete flood",
    code: [
      "function* floodFill(grid, start, end) {",
      "  const queue = [{ coord: start, dist: 0 }];",
      "  const visited = new Set([key(start)]);",
      "  const parent = new Map();",
      "  let foundEnd = false;",
      "",
      "  while (queue.length > 0) {",
      "    const { coord, dist } = queue.shift();",
      "    yield { type: 'current', coord, dist };",
      "",
      "    // Note if we found end (but keep going)",
      "    if (equals(coord, end)) foundEnd = true;",
      "",
      "    yield { type: 'visit', coord, dist };",
      "",
      "    // Explore ALL neighbors",
      "    for (const neighbor of getNeighbors(coord)) {",
      "      if (!visited.has(key(neighbor))) {",
      "        visited.add(key(neighbor));",
      "        parent.set(key(neighbor), coord);",
      "        queue.push({ coord: neighbor, dist: dist + 1 });",
      "      }",
      "    }",
      "  }",
      "",
      "  // Reconstruct path after complete flood",
      "  if (foundEnd) {",
      "    yield* reconstructPath(parent, start, end);",
      "  } else {",
      "    yield { type: 'no-path' };",
      "  }",
      "}",
    ],
    lineMapping: {
      current: 8,
      visit: 13,
      path: 27,
      "no-path": 29,
    },
  },

  random: {
    label: "Random Walk",
    shortLabel: "Random",
    complexity: "O(∞)",
    spaceComplexity: "O(V)",
    description:
      "Chaos mode: randomly picks a neighbor and moves there. No heuristics, no strategy. Demonstrates why intelligent search matters.",
    guaranteesShortestPath: false,
    visualPattern: "Chaotic wandering",
    code: [
      "function* randomWalk(grid, start, end) {",
      "  let current = start;",
      "  const MAX_STEPS = 1000;",
      "  const visited = new Set([key(start)]);",
      "  const parent = new Map();",
      "",
      "  for (let step = 0; step < MAX_STEPS; step++) {",
      "    const neighbors = getNeighbors(current);",
      "",
      "    if (neighbors.length === 0) {",
      "      yield { type: 'no-path' };",
      "      return;",
      "    }",
      "",
      "    // Pick random neighbor",
      "    const next = neighbors[Math.floor(",
      "      Math.random() * neighbors.length",
      "    )];",
      "",
      "    // Track first visit for path reconstruction",
      "    if (!visited.has(key(next))) {",
      "      parent.set(key(next), current);",
      "      visited.add(key(next));",
      "    }",
      "",
      "    current = next;",
      "    yield { type: 'current', coord: current };",
      "",
      "    if (equals(current, end)) {",
      "      yield* reconstructPath(parent, start, end);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord: current };",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 26,
      path: 29,
      visit: 33,
      "no-path": 36,
    },
  },

  bidirectional: {
    label: "Bidirectional A*",
    shortLabel: "Bi-A*",
    complexity: "O((V + E) log V)",
    spaceComplexity: "O(V)",
    description:
      "Tunnel bore: runs two A* searches simultaneously from Start and End, meeting in the middle. Explores roughly half the nodes of unidirectional A*.",
    guaranteesShortestPath: true,
    visualPattern: "Dual expanding bubbles",
    code: [
      "function* bidirectionalAStar(grid, start, end) {",
      "  // Forward search (start → end)",
      "  const openStart = new MinHeap();",
      "  const closedStart = new Set();",
      "  const parentStart = new Map();",
      "",
      "  // Backward search (end → start)",
      "  const openEnd = new MinHeap();",
      "  const closedEnd = new Set();",
      "  const parentEnd = new Map();",
      "",
      "  openStart.push({ coord: start, g: 0, f: h(start, end) });",
      "  openEnd.push({ coord: end, g: 0, f: h(end, start) });",
      "",
      "  while (openStart.size > 0 || openEnd.size > 0) {",
      "    // Expand from forward frontier",
      "    const fwd = expandNode(openStart, closedStart, ...);",
      "    yield { type: 'current', coord: fwd.coord };",
      "",
      "    // Check intersection with backward search",
      "    if (closedEnd.has(key(fwd.coord))) {",
      "      yield* stitchPath(parentStart, parentEnd, fwd);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord: fwd.coord };",
      "",
      "    // Expand from backward frontier",
      "    const bwd = expandNode(openEnd, closedEnd, ...);",
      "    yield { type: 'current', coord: bwd.coord };",
      "",
      "    // Check intersection with forward search",
      "    if (closedStart.has(key(bwd.coord))) {",
      "      yield* stitchPath(parentStart, parentEnd, bwd);",
      "      return;",
      "    }",
      "",
      "    yield { type: 'visit', coord: bwd.coord };",
      "  }",
      "",
      "  yield { type: 'no-path' };",
      "}",
    ],
    lineMapping: {
      current: 17,
      path: 21,
      visit: 25,
      "no-path": 39,
    },
  },
};

/**
 * Get metadata for a specific pathfinding algorithm.
 * Falls back to BFS if algorithm not found.
 */
export function getPathfindingAlgorithmMetadata(
  algorithm: PathfindingAlgorithmType
): PathfindingAlgorithmMetadata {
  return PATHFINDING_ALGO_METADATA[algorithm] ?? PATHFINDING_ALGO_METADATA.bfs;
}
